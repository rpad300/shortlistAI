"""
Database service for Chatbot CV Preparation feature.

Provides CRUD operations for chatbot-related database entities.
Separate from existing candidate/interviewer services to avoid interference.
"""

import json
from typing import Optional, Dict, Any, List
from uuid import UUID, uuid4
from datetime import datetime
import logging

from database.connection import get_supabase_client

logger = logging.getLogger(__name__)


class ChatbotDatabaseService:
    """
    Database service for chatbot feature.
    
    Handles all database operations for:
    - Chatbot sessions
    - Chatbot messages
    - CV versions generated by chatbot
    - Job opportunities analyzed by chatbot
    - Digital footprint analysis
    - Interview preparation materials
    - Employability scores
    """
    
    def __init__(self):
        self.supabase = get_supabase_client()
    
    # =========================================================================
    # Session Management
    # =========================================================================
    
    def create_session(
        self,
        candidate_id: Optional[UUID] = None,
        language: str = "en",
        profile_data: Optional[Dict[str, Any]] = None,
        consent_given: bool = False
    ) -> Optional[Dict[str, Any]]:
        """
        Create a new chatbot session.
        
        Args:
            candidate_id: Optional candidate ID if already known
            language: Language for conversation
            profile_data: Initial profile data
            consent_given: Whether consent was given
            
        Returns:
            Session dict or None if creation failed
        """
        try:
            session_data = {
                "candidate_id": str(candidate_id) if candidate_id else None,
                "current_step": "welcome",
                "status": "active",
                "language": language,
                "profile_data": profile_data or {},
                "consent_given": consent_given,
                "consent_timestamp": datetime.utcnow().isoformat() if consent_given else None,
                "started_at": datetime.utcnow().isoformat(),
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            response = self.supabase.table("chatbot_sessions").insert(session_data).execute()
            
            if response.data and len(response.data) > 0:
                logger.info(f"Created chatbot session: {response.data[0]['id']}")
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error creating chatbot session: {e}")
            return None
    
    def get_session(self, session_id: UUID) -> Optional[Dict[str, Any]]:
        """Get chatbot session by ID."""
        try:
            response = self.supabase.table("chatbot_sessions").select("*").eq("id", str(session_id)).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting chatbot session {session_id}: {e}")
            return None
    
    def update_session(
        self,
        session_id: UUID,
        updates: Dict[str, Any]
    ) -> bool:
        """
        Update chatbot session.
        
        Args:
            session_id: Session ID
            updates: Dictionary of fields to update
            
        Returns:
            True if update succeeded, False otherwise
        """
        try:
            updates["updated_at"] = datetime.utcnow().isoformat()
            
            response = self.supabase.table("chatbot_sessions").update(updates).eq("id", str(session_id)).execute()
            
            return response.data is not None and len(response.data) > 0
            
        except Exception as e:
            logger.error(f"Error updating chatbot session {session_id}: {e}")
            return False
    
    def complete_session(self, session_id: UUID) -> bool:
        """Mark session as completed."""
        return self.update_session(session_id, {
            "status": "completed",
            "completed_at": datetime.utcnow().isoformat(),
            "current_step": "completed"
        })
    
    # =========================================================================
    # Message Management
    # =========================================================================
    
    def add_message(
        self,
        session_id: UUID,
        role: str,
        content: str,
        message_type: str = "text",
        metadata: Optional[Dict[str, Any]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Add a message to the conversation.
        
        Args:
            session_id: Session ID
            role: Message role (user, bot, system)
            content: Message content
            message_type: Type of message
            metadata: Optional metadata
            
        Returns:
            Message dict or None if creation failed
        """
        try:
            message_data = {
                "session_id": str(session_id),
                "role": role,
                "content": content,
                "message_type": message_type,
                "metadata": metadata or {},
                "created_at": datetime.utcnow().isoformat()
            }
            
            response = self.supabase.table("chatbot_messages").insert(message_data).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error adding message to session {session_id}: {e}")
            return None
    
    def get_messages(self, session_id: UUID, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        """Get all messages for a session, ordered by creation time."""
        try:
            query = self.supabase.table("chatbot_messages").select("*").eq("session_id", str(session_id)).order("created_at", desc=False)
            
            if limit:
                query = query.limit(limit)
            
            response = query.execute()
            
            return response.data if response.data else []
            
        except Exception as e:
            logger.error(f"Error getting messages for session {session_id}: {e}")
            return []
    
    # =========================================================================
    # CV Version Management
    # =========================================================================
    
    def save_cv_version(
        self,
        session_id: UUID,
        version_type: str,
        cv_content: str,
        structured_data: Optional[Dict[str, Any]] = None,
        ats_score: Optional[int] = None,
        keyword_match_score: Optional[int] = None,
        language: str = "en"
    ) -> Optional[Dict[str, Any]]:
        """Save a generated CV version."""
        try:
            cv_data = {
                "session_id": str(session_id),
                "version_type": version_type,
                "cv_content": cv_content,
                "structured_data": structured_data or {},
                "ats_score": ats_score,
                "keyword_match_score": keyword_match_score,
                "language": language,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            response = self.supabase.table("chatbot_cv_versions").insert(cv_data).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error saving CV version for session {session_id}: {e}")
            return None
    
    def get_cv_versions(self, session_id: UUID) -> List[Dict[str, Any]]:
        """Get all CV versions for a session."""
        try:
            response = self.supabase.table("chatbot_cv_versions").select("*").eq("session_id", str(session_id)).execute()
            
            return response.data if response.data else []
            
        except Exception as e:
            logger.error(f"Error getting CV versions for session {session_id}: {e}")
            return []
    
    # =========================================================================
    # Job Opportunity Management
    # =========================================================================
    
    def save_job_opportunity(
        self,
        session_id: UUID,
        raw_text: Optional[str] = None,
        structured_data: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> Optional[Dict[str, Any]]:
        """Save job opportunity analysis."""
        try:
            job_data = {
                "session_id": str(session_id),
                "raw_text": raw_text,
                "structured_data": structured_data or {},
                "language": kwargs.get("language", "en"),
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            # Add optional fields
            for key in ["company_name", "company_website", "company_linkedin", 
                       "job_title", "location", "contract_type", "requirements_obligatory",
                       "requirements_preferred", "hard_skills", "soft_skills",
                       "culture_keywords", "risk_assessment", "quality_score"]:
                if key in kwargs:
                    job_data[key] = kwargs[key]
            
            response = self.supabase.table("chatbot_job_opportunities").insert(job_data).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error saving job opportunity for session {session_id}: {e}")
            return None
    
    def get_job_opportunity(self, session_id: UUID) -> Optional[Dict[str, Any]]:
        """Get job opportunity for a session."""
        try:
            response = self.supabase.table("chatbot_job_opportunities").select("*").eq("session_id", str(session_id)).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting job opportunity for session {session_id}: {e}")
            return None
    
    # =========================================================================
    # Digital Footprint Management
    # =========================================================================
    
    def save_digital_footprint(
        self,
        session_id: UUID,
        linkedin_url: Optional[str] = None,
        github_url: Optional[str] = None,
        portfolio_url: Optional[str] = None,
        other_links: Optional[List[str]] = None,
        linkedin_analysis: Optional[Dict[str, Any]] = None,
        github_analysis: Optional[Dict[str, Any]] = None,
        portfolio_analysis: Optional[Dict[str, Any]] = None,
        inconsistencies: Optional[List[Dict[str, Any]]] = None,
        recommendations: Optional[List[str]] = None
    ) -> Optional[Dict[str, Any]]:
        """Save digital footprint analysis."""
        try:
            footprint_data = {
                "session_id": str(session_id),
                "linkedin_url": linkedin_url,
                "github_url": github_url,
                "portfolio_url": portfolio_url,
                "other_links": other_links or [],
                "linkedin_analysis": linkedin_analysis or {},
                "github_analysis": github_analysis or {},
                "portfolio_analysis": portfolio_analysis or {},
                "inconsistencies": inconsistencies or [],
                "recommendations": recommendations or [],
                "analyzed_at": datetime.utcnow().isoformat() if (linkedin_analysis or github_analysis or portfolio_analysis) else None,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            response = self.supabase.table("chatbot_digital_footprint").insert(footprint_data).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error saving digital footprint for session {session_id}: {e}")
            return None
    
    def get_digital_footprint(self, session_id: UUID) -> Optional[Dict[str, Any]]:
        """Get digital footprint analysis for a session."""
        try:
            response = self.supabase.table("chatbot_digital_footprint").select("*").eq("session_id", str(session_id)).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting digital footprint for session {session_id}: {e}")
            return None
    
    # =========================================================================
    # Interview Preparation Management
    # =========================================================================
    
    def save_interview_prep(
        self,
        session_id: UUID,
        likely_questions: Optional[List[Dict[str, Any]]] = None,
        suggested_answers: Optional[List[Dict[str, Any]]] = None,
        key_stories: Optional[List[Dict[str, Any]]] = None,
        preparation_summary: Optional[str] = None,
        questions_to_ask: Optional[List[str]] = None,
        language: str = "en"
    ) -> Optional[Dict[str, Any]]:
        """Save interview preparation materials."""
        try:
            prep_data = {
                "session_id": str(session_id),
                "likely_questions": likely_questions or [],
                "suggested_answers": suggested_answers or [],
                "key_stories": key_stories or [],
                "preparation_summary": preparation_summary,
                "questions_to_ask": questions_to_ask or [],
                "language": language,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            response = self.supabase.table("chatbot_interview_prep").insert(prep_data).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error saving interview prep for session {session_id}: {e}")
            return None
    
    def get_interview_prep(self, session_id: UUID) -> Optional[Dict[str, Any]]:
        """Get interview preparation materials for a session."""
        try:
            response = self.supabase.table("chatbot_interview_prep").select("*").eq("session_id", str(session_id)).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting interview prep for session {session_id}: {e}")
            return None
    
    # =========================================================================
    # Employability Score Management
    # =========================================================================
    
    def save_employability_score(
        self,
        session_id: UUID,
        overall_score: int,
        technical_skills_score: Optional[int] = None,
        experience_score: Optional[int] = None,
        communication_score: Optional[int] = None,
        strengths: Optional[List[str]] = None,
        weaknesses: Optional[List[str]] = None,
        recommendations: Optional[List[str]] = None
    ) -> Optional[Dict[str, Any]]:
        """Save employability score and analysis."""
        try:
            score_data = {
                "session_id": str(session_id),
                "overall_score": overall_score,
                "technical_skills_score": technical_skills_score,
                "experience_score": experience_score,
                "communication_score": communication_score,
                "strengths": strengths or [],
                "weaknesses": weaknesses or [],
                "recommendations": recommendations or [],
                "calculated_at": datetime.utcnow().isoformat(),
                "created_at": datetime.utcnow().isoformat()
            }
            
            response = self.supabase.table("chatbot_employability_scores").insert(score_data).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error saving employability score for session {session_id}: {e}")
            return None
    
    def get_employability_score(self, session_id: UUID) -> Optional[Dict[str, Any]]:
        """Get employability score for a session."""
        try:
            response = self.supabase.table("chatbot_employability_scores").select("*").eq("session_id", str(session_id)).execute()
            
            if response.data and len(response.data) > 0:
                return response.data[0]
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting employability score for session {session_id}: {e}")
            return None


# Singleton instance
_chatbot_service_instance: Optional[ChatbotDatabaseService] = None


def get_chatbot_database_service() -> ChatbotDatabaseService:
    """Get singleton instance of ChatbotDatabaseService."""
    global _chatbot_service_instance
    if _chatbot_service_instance is None:
        _chatbot_service_instance = ChatbotDatabaseService()
    return _chatbot_service_instance

